{*
 * SedaiBasic - A BASIC interpreter with bytecode VM
 * Copyright (C) 2025 Maurizio Cammalleri
 *
 * This program is dual-licensed:
 *
 * 1) For open source use: GNU General Public License version 3 (GPL-3.0-only)
 *    You may redistribute and/or modify it under the terms of the GNU GPL v3
 *    as published by the Free Software Foundation.
 *    See <https://www.gnu.org/licenses/gpl-3.0.html>
 *
 * 2) For commercial/proprietary use: A separate commercial license is required.
 *    Contact: maurizio.cammalleri@gmail.com for licensing inquiries.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * SPDX-License-Identifier: GPL-3.0-only OR Commercial
 *}
{ ============================================================================
  Unit: SedaiCopyCoalescing (Copy Coalescing Optimization)

  Purpose: Eliminate redundant Copy instructions generated by PHI Elimination.

  Algorithm:
    1. Identify Copy instructions: r1 := Copy r2
    2. Check coalescing safety (no interference, compatible types)
    3. Replace all uses of r1 with r2 (propagate)
    4. Mark Copy instruction as dead (DCE will remove it)

  Key Features:
    - Reduces instruction count after PHI Elimination
    - Preserves program semantics
    - Conservative: only coalesces when safe
    - Compatible with GlobalVariableSemantics (Version=0)

  Safety Conditions:
    - r1 and r2 must have same register type (Int/Float/String)
    - r1 must be defined only once (SSA property)
    - No live range interference (for SSA mode with versioning)
    - For BASIC mode: be conservative with user variables

  Phase: Post-PHI-Elimination, Pre-Register-Allocation
  Author: Sedai Project - Optimization Passes
  Date: 2025-01-27
  ============================================================================ }

unit SedaiCopyCoalescing;

{$mode objfpc}{$H+}
{$interfaces CORBA}
{$codepage UTF8}
{$inline on}
{$I OptimizationFlags.inc}
{$I DebugFlags.inc}

interface

uses
  Classes, SysUtils, SedaiSSATypes;

type
  { TCopyCoalescing - Copy coalescing optimization }
  TCopyCoalescing = class
  private
    FProgram: TSSAProgram;
    FCoalescedCount: Integer;

    { Check if instruction is a Copy instruction (any type) }
    function IsCopyInstruction(Instr: TSSAInstruction): Boolean; inline;

    { Check if a Copy instruction can be safely coalesced }
    function CanCoalesce(Instr: TSSAInstruction): Boolean;

    { Replace all uses of OldVal with NewVal in the program }
    procedure ReplaceAllUses(const OldVal, NewVal: TSSAValue);

    { Check if value is a user variable (conservative for BASIC) }
    function IsUserVariable(const Val: TSSAValue): Boolean;

  public
    constructor Create(Prog: TSSAProgram);
    destructor Destroy; override;

    { Run copy coalescing - returns number of copies coalesced }
    function Run: Integer;
  end;

implementation

{$IFDEF DEBUG_COPYCOAL}
uses SedaiDebug;
{$ENDIF}

{ TCopyCoalescing }

constructor TCopyCoalescing.Create(Prog: TSSAProgram);
begin
  inherited Create;
  FProgram := Prog;
  FCoalescedCount := 0;
end;

destructor TCopyCoalescing.Destroy;
begin
  inherited;
end;

function TCopyCoalescing.IsCopyInstruction(Instr: TSSAInstruction): Boolean;
begin
  Result := (Instr.OpCode = ssaCopyInt) or
            (Instr.OpCode = ssaCopyFloat) or
            (Instr.OpCode = ssaCopyString);
end;

function TCopyCoalescing.Run: Integer;
var
  i, j: Integer;
  Block: TSSABasicBlock;
  Instr: TSSAInstruction;
  OldDest, NewSrc: TSSAValue;
begin
  {$IFDEF DISABLE_COPY_COAL}
  {$IFDEF DEBUG_COPYCOAL}
  if DebugCopyCoal then
    WriteLn('[CopyCoal] SKIPPED (disabled by flag)');
  {$ENDIF}
  Result := 0;
  Exit;
  {$ENDIF}

  {$IFDEF DEBUG_COPYCOAL}
  if DebugCopyCoal then
    WriteLn('[CopyCoal] Running Copy Coalescing optimization...');
  {$ENDIF}
  FCoalescedCount := 0;

  // Scan all blocks and instructions for Copy operations
  for i := 0 to FProgram.Blocks.Count - 1 do
  begin
    Block := FProgram.Blocks[i];
    for j := 0 to Block.Instructions.Count - 1 do
    begin
      Instr := Block.Instructions[j];

      // Check if this is a Copy instruction we can coalesce
      if IsCopyInstruction(Instr) and CanCoalesce(Instr) then
      begin
        OldDest := Instr.Dest;
        NewSrc := Instr.Src1;

        {$IFDEF DEBUG_COPYCOAL}
        if DebugCopyCoal then
          WriteLn('[CopyCoal] Coalescing: r', OldDest.RegIndex, '_v', OldDest.Version,
                  ' â†’ r', NewSrc.RegIndex, '_v', NewSrc.Version);
        {$ENDIF}

        // Replace all uses of destination with source
        ReplaceAllUses(OldDest, NewSrc);

        // Mark this Copy as dead (will be removed by DCE or becomes NOP)
        Instr.OpCode := ssaNop;

        Inc(FCoalescedCount);
      end;
    end;
  end;

  {$IFDEF DEBUG_COPYCOAL}
  if DebugCopyCoal then
    WriteLn('[CopyCoal] Coalesced ', FCoalescedCount, ' copy instructions');
  {$ENDIF}
  Result := FCoalescedCount;
end;

function TCopyCoalescing.CanCoalesce(Instr: TSSAInstruction): Boolean;
begin
  Result := False;

  // Must be a Copy instruction (caller should check this first, but verify)
  if not IsCopyInstruction(Instr) then Exit;

  // Destination and source must be registers
  if (Instr.Dest.Kind <> svkRegister) or (Instr.Src1.Kind <> svkRegister) then
    Exit;

  // Must have same register type
  if Instr.Dest.RegType <> Instr.Src1.RegType then
    Exit;

  // CRITICAL SAFETY: Don't coalesce if source register is a user variable
  // User variables can be redefined later, making coalescing unsafe
  // Example: Copy R0 := R5, then later R5 := newvalue
  // If we replace uses of R0 with R5, they would get the WRONG value after R5 is redefined
  if IsUserVariable(Instr.Src1) then
  begin
    {$IFDEF DEBUG_COPYCOAL}
    if DebugCopyCoal then
      WriteLn('[CopyCoal] Skipping coalescing - source r', Instr.Src1.RegIndex,
              ' is a user variable (could be redefined)');
    {$ENDIF}
    Exit;
  end;

  // CONSERVATIVE: For BASIC mode with user variables, be extra careful
  // Don't coalesce if destination is a user variable (could break semantics)
  if FProgram.GlobalVariableSemantics then
  begin
    if IsUserVariable(Instr.Dest) then
    begin
      {$IFDEF DEBUG_COPYCOAL}
      if DebugCopyCoal then
        WriteLn('[CopyCoal] Skipping coalescing for user variable r',
                Instr.Dest.RegIndex, '_v', Instr.Dest.Version);
      {$ENDIF}
      Exit;
    end;
  end;

  // Safe to coalesce
  Result := True;
end;

function TCopyCoalescing.IsUserVariable(const Val: TSSAValue): Boolean;
var
  i: Integer;
  VarKey: string;
begin
  Result := False;

  if Val.Kind <> svkRegister then Exit;

  // Build key: "RegType:RegIndex"
  VarKey := IntToStr(Ord(Val.RegType)) + ':' + IntToStr(Val.RegIndex);

  // Check if this register maps to a BASIC user variable
  for i := 0 to FProgram.VarRegMap.Count - 1 do
  begin
    if FProgram.VarRegMap.ValueFromIndex[i] = VarKey then
    begin
      Result := True;
      Exit;
    end;
  end;
end;

procedure TCopyCoalescing.ReplaceAllUses(const OldVal, NewVal: TSSAValue);
var
  i, j: Integer;
  Block: TSSABasicBlock;
  Instr: TSSAInstruction;

  function ReplaceValue(const Val: TSSAValue): TSSAValue;
  begin
    Result := Val;
    if (Val.Kind = svkRegister) and
       (Val.RegType = OldVal.RegType) and
       (Val.RegIndex = OldVal.RegIndex) and
       (Val.Version = OldVal.Version) then
    begin
      Result := NewVal;
    end;
  end;

begin
  // Scan all instructions and replace uses
  for i := 0 to FProgram.Blocks.Count - 1 do
  begin
    Block := FProgram.Blocks[i];
    for j := 0 to Block.Instructions.Count - 1 do
    begin
      Instr := Block.Instructions[j];

      // Replace in source operands (but NOT in destinations)
      Instr.Src1 := ReplaceValue(Instr.Src1);
      Instr.Src2 := ReplaceValue(Instr.Src2);
      Instr.Src3 := ReplaceValue(Instr.Src3);

      // NOTE: We do NOT replace Dest because that would change the definition point
      // The old Dest becomes dead code (no more uses), DCE will remove it
    end;
  end;
end;

end.
